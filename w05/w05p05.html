<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>W5P5</title>
      <!-- External JavaScript Files -->
      <script type="text/javascript" src="w05p05.js" defer></script>
      <script type="text/javascript" src="MV.js" defer></script>
      <script type="text/javascript" src="OBJParser.js" defer></script>
    
    <!-- Stylesheet -->
    <style>
        /* Body Styling */
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            text-align: center;
            margin: 2em;
        }

        /* Canvas Styling */
        canvas {
            display: block;
            margin: 1em auto;
            border: 1px solid #ccc;
            background-color: #fff;
            max-width: 100%;
            height: auto;
        }

        /* Button Styling */
        button {
            padding: 0.5em 1em;
            font-size: 1em;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s ease;
            margin: 0.5em;
        }

        /* Button Hover Effect */
        button:hover {
            background-color: #0056b3;
        }

        /* Range Input Styling */
        input[type="range"] {
            width: 300px;
            height: 8px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            margin: 1em 0;
        }

        /* Range Slider Thumb Styling */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        /* Range Slider Thumb Hover Effect */
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #0056b3;
        }

        /* Select Dropdown Styling */
        select {
            padding: 0.5em 1em;
            font-size: 1em;
            background-color: #ffffff;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            margin: 1em 0.5em;
        }

        /* Select Dropdown Hover and Focus Effects */
        select:hover, select:focus {
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
            outline: none;
        }

        /* Option Styling (Optional) */
        select option {
            padding: 0.5em;
        }

        /* Controls Container Styling */
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 1em;
        }

        /* Label Styling */
        label {
            margin-right: 0.5em;
            font-weight: bold;
        }

        /* Shader Selection Dropdown Styling */
        #shaderSphereMenu {
            margin-top: 1em;
        }

        /* Subdivisions Menu Styling */
        #subdivsMenu {
            margin-top: 1em;
        }
    </style>
</head>
<body>
    <!-- Shader Code -->
    <script id="wgsl" type="x-shader">
        // ========================
        // WGSL Shader Code
        // ========================

        // ------------------------
        // Struct Definitions
        // ------------------------

        // Struct to hold uniform variables
        struct Uniforms {
            aspect : f32,        // Aspect ratio of the canvas
            cam_constant : f32,  // Camera constant for ray generation
        };

        // Binding group 0, binding 0: Uniform buffer
        @group(0) @binding(0) var<uniform> uniforms : Uniforms;

        // Binding group 0, binding 1: Vertex positions (storage buffer)
        @group(0) @binding(1) var<storage> vPositions : array<vec3f>;

        // Binding group 0, binding 2: Mesh faces (storage buffer)
        @group(0) @binding(2) var<storage> meshFaces : array<vec3u>;

        // Binding group 0, binding 3: Vertex normals (storage buffer)
        @group(0) @binding(3) var<storage> vNormals : array<vec3f>;

        // Binding group 0, binding 4: Material colors (storage buffer)
        @group(0) @binding(4) var<storage> materialColor : array<vec4f>;

        // Binding group 0, binding 5: Material emissions (storage buffer)
        @group(0) @binding(5) var<storage> materialEmission : array<vec4f>;

        // Binding group 0, binding 6: Material indices (storage buffer)
        @group(0) @binding(6) var<storage> matIndices : array<u32>;

        // Binding group 0, binding 7: Light indices (storage buffer)
        @group(0) @binding(7) var<storage> lightIndices : array<u32>;

        // Struct to pass data from vertex shader to fragment shader
        struct VSOut {
            @builtin(position) position : vec4f, // Position in clip space
            @location(0) coords : vec2f,         // Texture coordinates
        }

        // Struct to represent a light source
        struct Light {
            L_i: f32,          // Intensity of the light
            w_i: vec3f,        // Direction or position of the light
            dist: f32,         // Distance to the light source
        }

        // Struct to represent a ray in the scene
        struct Ray {
            origin : vec3f,    // Origin point of the ray
            direction : vec3f, // Direction vector of the ray
            t_min : f32,       // Minimum distance for intersection
            t_max : f32,       // Maximum distance for intersection
        }

        // Struct to hold information about a ray intersection
        struct HitInfo {
            has_hit : bool,    // Whether the ray hit an object
            dist : f32,        // Distance to the hit point
            position : vec3f,  // Position of the hit
            normal : vec3f,    // Normal at the hit point
            color : vec3f,     // Color at the hit point
            depth : u32,       // Depth information (unused here)
            shader : u32,      // Shader type identifier
        };

        // Struct for Orthonormal Basis (Unused in current code)
        struct Onb {
            tangent: vec3f,
            binormal: vec3f,
            normal: vec3f,
        };

        // ------------------------
        // Constants
        // ------------------------

        const PI: f32 = 3.14159265359; // Pi constant

        // ------------------------
        // Vertex Shader
        // ------------------------

        @vertex
        fn main_vs(@builtin(vertex_index) VertexIndex : u32) -> VSOut {
            // Define the positions of the vertices in clip space
            const pos = array<vec2f, 4>(
                vec2f(-1.0, 1.0),
                vec2f(-1.0, -1.0),
                vec2f(1.0, 1.0),
                vec2f(1.0, -1.0)
            );
            var vsOut: VSOut;
            vsOut.position = vec4f(pos[VertexIndex], 0.0, 1.0); // Set clip space position
            vsOut.coords = pos[VertexIndex];                      // Pass texture coordinates
            return vsOut;
        }

        // ------------------------
        // Ray Generation
        // ------------------------

        // Generates a camera ray based on normalized device coordinates (uv)
        fn get_camera_ray(uv: vec2f) -> Ray {
            var p = vec3f(277.0, 275.0, 0.0); // Pivot point (unused in current context)
            var up_vec = vec3f(0.0, 1.0, 0.0); // Up vector for camera orientation
            var r: Ray;
            r.origin = vec3f(277.0, 275.0, -570.0); // Camera position in world space
            var v = normalize(p - r.origin);         // Forward vector
            var b1 = normalize(cross(v, up_vec));    // Right vector
            var b2 = cross(b1, v);                    // Recomputed up vector
            var q = b1 * uv.x + b2 * uv.y + v * uniforms.cam_constant; // Direction computation
            r.direction = normalize(q);              // Normalize direction
            r.t_min = 0.0;                           // Minimum intersection distance
            r.t_max = 1.0e32;                        // Maximum intersection distance
            return r;
        }

        // ------------------------
        // Intersection Tests
        // ------------------------

        // Tests intersection between a ray and a triangle
        fn intersect_triangle(r: Ray, hit: ptr<function, HitInfo>, f_index: u32) -> bool {
            var f = meshFaces[f_index];              // Get face indices
            //var n = vNormals[f_index];             // Optional: Normal per face (commented out)
            var v0 = vPositions[f.x];                // Vertex 0
            var v1 = vPositions[f.y];                // Vertex 1
            var v2 = vPositions[f.z];                // Vertex 2
            var n0 = vNormals[f.x];                  // Normal at Vertex 0
            var n1 = vNormals[f.y];                  // Normal at Vertex 1
            var n2 = vNormals[f.z];                  // Normal at Vertex 2

            var e0 = v1 - v0;                         // Edge 1
            var e1 = v2 - v0;                         // Edge 2
            var normal = cross(e0, e1);               // Triangle normal

            // Check if the ray is parallel to the triangle
            if ((abs(dot(r.direction, normal))) < 1e-8) {
                return false;
            }

            // Compute barycentric coordinates
            var beta = dot(cross(v0 - r.origin, r.direction), e1) / dot(r.direction, normal);
            var gamma = -dot(cross(v0 - r.origin, r.direction), e0) / dot(r.direction, normal);

            // Check if the intersection point is inside the triangle
            if (beta >= 0 && gamma >= 0 && beta + gamma <= 1) {
                var t_prime = dot(v0 - r.origin, normal) / dot(r.direction, normal); // Intersection distance
                if (t_prime > r.t_min && t_prime < r.t_max) {
                    (*hit).has_hit = true;
                    (*hit).dist = t_prime;
                    (*hit).position = r.origin + t_prime * r.direction; // Hit position
                    // Interpolate normals using barycentric coordinates for smooth shading
                    (*hit).normal = normalize((1.0 - beta - gamma) * n0 + beta * n1 + gamma * n2);
                    return true;
                }
            }
            return false;
        }

        // Tests intersection between a ray and the entire scene
        fn intersect_scene(r: ptr<function, Ray>, hit: ptr<function, HitInfo>) -> bool {
            for (var c: u32 = 0; c < arrayLength(&meshFaces); c++) {
                if (intersect_triangle((*r), hit, c)) {
                    // Combine material color and emission
                    (*hit).color = (materialColor[matIndices[c]] + materialEmission[matIndices[c]]).xyz;
                    //(*hit).color = vec3f(0.9, 0.9, 0.9); // Simple gray color (commented out)
                    (*hit).shader = 1;                    // Set shader type
                    (*r).t_max = (*hit).dist;             // Update ray's max distance
                }
            }
            return (*hit).has_hit;
        }

        // ------------------------
        // Lighting Calculations
        // ------------------------

        // Samples a point light at a given position
        fn sample_point_light(pos: vec3f) -> Light {
            var light: Light;
            var light_pos = vec3f(0.0, 1.0, 0.0); // Position of the point light
            light.L_i = PI / dot(light_pos - pos, light_pos - pos); // Light intensity based on distance
            light.w_i = normalize(light_pos - pos);                // Light direction
            light.dist = length(light_pos - pos);                  // Distance to light
            return light;
        }

        // Samples a directional light
        fn sample_directional_light(pos: vec3f) -> Light {
            var dir_light: Light;
            dir_light.L_i = 3.0;                             // Fixed intensity for directional light
            dir_light.w_i = normalize(vec3f(-1.0, -0.0, 1.0)); // Direction of the light
            dir_light.dist = 1.0e8;                           // Directional light has effectively infinite distance
            //dir_light.dist = 0.0;                          // Alternative: Zero distance (commented out)

            return dir_light;
        }

        // Calculates area-based light sampling
        fn sample_area_light(pos: vec3f) -> Light {
            var area_light: Light;
            var L_e = 30.0;                                  // Emission intensity
            var light_pos = vec3f(0.0);                      // Accumulator for light positions

            // Calculate average center position of all area lights
            for (var c: u32 = 0; c < arrayLength(&lightIndices); c++) {
                var lightIndex = lightIndices[c];
                var f = meshFaces[lightIndex];
                let center = calculate_center(vPositions[f.x], vPositions[f.y], vPositions[f.z]);
                light_pos += center;
            }
            light_pos /= f32(arrayLength(&lightIndices));

            // Calculate light direction and initial intensity
            area_light.w_i = (light_pos - pos);
            for (var c: u32 = 0; c < arrayLength(&lightIndices); c++) {
                var lightIndex = lightIndices[c];
                var f = meshFaces[lightIndex];
                let emission = materialEmission[matIndices[lightIndex]];
                area_light.L_i += max(dot(-normalize(area_light.w_i), calculate_normal_area(vPositions[f.x], vPositions[f.y], vPositions[f.z])), 0.0) * L_e;
            }
            var r = length(light_pos - pos);
            area_light.L_i /= pow(r, 2);                      // Attenuate intensity based on distance
            area_light.dist = length(area_light.w_i);         // Distance to light
            area_light.w_i = normalize(area_light.w_i);       // Normalize direction
            return area_light;
        }

        // Calculates the area of a triangle
        fn calculate_area(v1: vec3f, v2: vec3f, v3: vec3f) -> f32 {
            var AB = v2 - v1;
            var AC = v3 - v1;
            return 0.5 * length(cross(AB, AC));
        }

        // Calculates the normal area (unused)
        fn calculate_normal_area(v1: vec3f, v2: vec3f, v3: vec3f) -> vec3f {
            var AB = v2 - v1;
            var AC = v3 - v1;
            return 0.5 * cross(AB, AC);
        }

        // Calculates the center of a triangle
        fn calculate_center(v1: vec3f, v2: vec3f, v3: vec3f) -> vec3f {
            var x = (v1.x + v2.x + v3.x) / 3.0;
            var y = (v1.y + v2.y + v3.y) / 3.0;
            var z = (v1.z + v2.z + v3.z) / 3.0;
            return vec3f(x, y, z);
        }

        // Calculates Lambertian reflectance
        fn lambertian(r: ptr<function, Ray>, hit: ptr<function, HitInfo>) -> vec3f {
            // Choose between point light and area light
            // var light: Light = sample_point_light((*hit).position);
            // var light: Light = sample_directional_light((*hit).position);
            var light: Light = sample_area_light((*hit).position);
            
            var L_a = (*hit).color * 0.1;  // Ambient light component
            var ro = (*hit).color * 0.9;   // Reflective color

            // Diffuse reflectance based on Lambert's cosine law
            var L_r = ro * light.L_i * max(dot(light.w_i, normalize((*hit).normal)), 0.0) / PI;

            // Shadow ray to check for occlusions
            var shadow_ray = Ray((*hit).position, light.w_i, 1.0e-2, light.dist - 1.0e-2);
            var shadow_hit = HitInfo(false, 0.0, vec3f(0.0), vec3f(0.0), vec3f(0.0), 0, 1);

            // If the shadow ray intersects the scene, only ambient light contributes
            if (intersect_scene(&shadow_ray, &shadow_hit)) {
                return L_a;
            } else {
                return L_r + L_a; // Add diffuse and ambient light
            }
        }

        // ------------------------
        // Shading Function
        // ------------------------

        // Determines the color based on the shader type
        fn shade(r: ptr<function, Ray>, hit: ptr<function, HitInfo>) -> vec3f {
            switch (*hit).shader {
                case 0 {
                    return (*hit).color; // Simple color shading
                }
                case 1 {
                    return lambertian(r, hit); // Lambertian shading
                }
                default {
                    return (*hit).color; // Default to simple color shading
                }
            }
        }

        // ------------------------
        // Fragment Shader
        // ------------------------

        @fragment
        fn main_fs(@location(0) coords: vec2f) -> @location(0) vec4f {
            const bgcolor = vec4f(0.1, 0.3, 0.6, 1.0); // Background color
            const max_depth = 10;                        // Maximum recursion depth
            var result = vec3f(0.0);                     // Accumulated color result

            // Convert coordinates to UV space
            var uv = vec2f(coords.x * uniforms.aspect * 0.5, coords.y * 0.5);

            // Generate camera ray based on UV coordinates
            var r = get_camera_ray(uv);

            // Initialize hit information
            var hit = HitInfo(false, 0.0, vec3f(0.0), vec3f(0.0), vec3f(0.0), 0, 1);

            // Perform ray tracing
            for (var i = 0; i < max_depth; i++) {
                if (intersect_scene(&r, &hit)) {
                    result += shade(&r, &hit); // Accumulate shading
                } else {
                    result += bgcolor.rgb;     // Accumulate background color
                    break;
                }
                if (hit.has_hit) { 
                    break; // Stop if a hit is detected
                }
            }

            // Return the final color with alpha transparency
            return vec4f(result, bgcolor.a);
        }
    </script>

    <!-- WebGPU Canvas -->
    <canvas id="webgpu-canvas" width="512" height="512">
        Please use a browser that supports HTML5 canvas.
    </canvas>
    
</body>
</html>
