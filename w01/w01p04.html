<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>W1P4</title>
    
    <!-- Load the JavaScript files with defer to ensure they run after the HTML is parsed -->
    <script src="MV.js" defer></script>
    <script src="w01p04.js" defer></script>
    
    <!-- WebGPU Shader in WGSL -->
    <script id="wgsl" type="text/wgsl">
        const PI: f32 = 3.14159265359; // Define PI

        struct VSOut {           
            @builtin(position) position: vec4f,           
            @location(0)       coords  : vec2f,         
        };     
        
        @vertex    
        fn main_vs(@builtin(vertex_index) VertexIndex: u32) -> VSOut {      
            const pos = array<vec2f, 4>(
                vec2f(-1.0,  1.0), 
                vec2f(-1.0, -1.0), 
                vec2f( 1.0,  1.0), 
                vec2f( 1.0, -1.0)
            );       
            var vsOut: VSOut;
            vsOut.position = vec4f(pos[VertexIndex], 0.0, 1.0);
            vsOut.coords = pos[VertexIndex];
            return vsOut;
        }
        
        // Define Ray struct
        struct Ray {   
            origin: vec3f,  
            direction: vec3f,  
            tmin: f32,   
            tmax: f32 
        };
        
        fn get_camera_ray(ipcoords: vec2f) -> Ray {
            let eye = vec3f(2.0, 1.5, 2.0); // Camera position
            let look_at = vec3f(0.0, 0.5, 0.0); // Where the camera is looking
            let up = vec3f(0.0, 1.0, 0.0); // Up direction

            let forward = normalize(look_at - eye);
            let right = normalize(cross(forward, up));
            let true_up = cross(right, forward);

            let aspect_ratio = 1.0; // Assuming square canvas
            let fov_scale = tan(1.0 * 0.5); // FOV (camera constant)
            
            let ray_dir = normalize(forward + ipcoords.x * aspect_ratio * fov_scale * right + ipcoords.y * fov_scale * true_up);
            
            return Ray(eye, ray_dir, 0.0, 100.0); // Adjust tmax as needed
        }

        struct HitInfo {
            hit: bool,      // Whether the ray hit an object
            distance: f32,  // Distance to the intersection point
            color: vec3f,   // Color of the intersected object
        };

        fn intersect_plane(ray: Ray, plane_pos: vec3f, plane_normal: vec3f) -> HitInfo {
            let denom = dot(plane_normal, ray.direction);
            if (abs(denom) > 1e-6) {
                let t = dot(plane_pos - ray.origin, plane_normal) / denom;
                if (t > ray.tmin && t < ray.tmax) {
                    return HitInfo(true, t, vec3f(0.1, 0.7, 0.0)); // Plane color (greenish)
                }
            }
            return HitInfo(false, ray.tmax, vec3f(0.0, 0.0, 0.0)); // No intersection
        }

        fn intersect_sphere(ray: Ray, center: vec3f, radius: f32) -> HitInfo {
            let oc = ray.origin - center;
            let a = dot(ray.direction, ray.direction);
            let b = 2.0 * dot(oc, ray.direction);
            let c = dot(oc, oc) - radius * radius;
            let discriminant = b * b - 4.0 * a * c;
        
            if (discriminant > 0.0) {
                let t = (-b - sqrt(discriminant)) / (2.0 * a);
                if (t > ray.tmin && t < ray.tmax) {
                    return HitInfo(true, t, vec3f(0.0, 0.0, 0.0)); // Sphere color (black)
                }
            }
            return HitInfo(false, ray.tmax, vec3f(0.0, 0.0, 0.0)); // No intersection
        }

        fn intersect_triangle(ray: Ray, v0: vec3f, v1: vec3f, v2: vec3f) -> HitInfo {
            let edge1 = v1 - v0;
            let edge2 = v2 - v0;
            let h = cross(ray.direction, edge2);
            let a = dot(edge1, h);
        
            if (abs(a) < 1e-6) {
                return HitInfo(false, ray.tmax, vec3f(0.0, 0.0, 0.0)); // No intersection
            }
        
            let f = 1.0 / a;
            let s = ray.origin - v0;
            let u = f * dot(s, h);
            if (u < 0.0 || u > 1.0) {
                return HitInfo(false, ray.tmax, vec3f(0.0, 0.0, 0.0)); // No intersection
            }
        
            let q = cross(s, edge1);
            let v = f * dot(ray.direction, q);
            if (v < 0.0 || u + v > 1.0) {
                return HitInfo(false, ray.tmax, vec3f(0.0, 0.0, 0.0)); // No intersection
            }
        
            let t = f * dot(edge2, q);
            if (t > ray.tmin && t < ray.tmax) {
                return HitInfo(true, t, vec3f(0.4, 0.3, 0.2)); // Triangle color (brown)
            }
            return HitInfo(false, ray.tmax, vec3f(0.0, 0.0, 0.0)); // No intersection
        }

        fn calculate_specular(hit_position: vec3f, normal: vec3f, ray_dir: vec3f, shininess: f32) -> vec3f {
                    let light_pos = vec3f(0.0, 1.0, 0.0);
                    let light_dir = normalize(light_pos - hit_position);
                    
                    let view_dir = normalize(-ray_dir); // Ray direction points away from the view
                    let reflect_dir = reflect(-light_dir, normal);
                    
                    let specular = pow(max(dot(view_dir, reflect_dir), 0.0), shininess);
                    return vec3f(specular, specular, specular); // White specular highlight
        }

        fn calculate_lighting(hit_position: vec3f, normal: vec3f, object_color: vec3f) -> vec3f {
            let light_pos = vec3f(0.0, 1.0, 0.0);
            let light_intensity = vec3f(PI, PI, PI); // Light intensity as (π, π, π)
            
            let light_dir = normalize(light_pos - hit_position);
            let diffuse = max(dot(normal, light_dir), 0.0);
            
            let lighting = object_color * light_intensity * diffuse;
            return lighting;
        }

        
        
        @fragment     
        fn main_fs(@location(0) coords: vec2f) -> @location(0) vec4f {    
            let ipcoords = coords * 0.5;
    
            // Generate a camera ray
            var ray = get_camera_ray(ipcoords);
            
            // Initialize background color (light blue) and max distance
            var closestHit = HitInfo(false, ray.tmax, vec3f(0.5, 0.7, 1.0)); // Light blue

            // Test intersection with plane
            let planeHit = intersect_plane(ray, vec3f(0.0, 0.0, 0.0), vec3f(0.0, 1.0, 0.0));
            if (planeHit.hit && planeHit.distance < closestHit.distance) {
                closestHit = planeHit;
                ray.tmax = planeHit.distance;
            }

            // Test intersection with sphere
            let sphereHit = intersect_sphere(ray, vec3f(0.0, 0.5, 0.0), 0.3);
            if (sphereHit.hit && sphereHit.distance < closestHit.distance) {
                closestHit = sphereHit;
                ray.tmax = sphereHit.distance;
            }

            // Test intersection with triangle
            let triangleHit = intersect_triangle(
                ray,
                vec3f(-0.2, 0.1, 0.9), 
                vec3f(0.2, 0.1, 0.9), 
                vec3f(0.0, 0.1, -0.1)
            );
            if (triangleHit.hit && triangleHit.distance < closestHit.distance) {
                closestHit = triangleHit;
                ray.tmax = triangleHit.distance;
            }

            if (closestHit.hit) {
                let hit_position = ray.origin + ray.direction * closestHit.distance;
                var normal: vec3f = vec3f(0.0, 0.0, 0.0);
                
                // Determine the normal based on the object hit
                if (planeHit.hit) {
                    normal = vec3f(0.0, 1.0, 0.0); // Plane normal
                } else if (sphereHit.hit) {
                    normal = normalize(hit_position - vec3f(0.0, 0.5, 0.0)); // Sphere normal
                } else if (triangleHit.hit) {
                    normal = normalize(cross(vec3f(0.2, 0.1, 0.9) - vec3f(-0.2, 0.1, 0.9), vec3f(0.0, 0.1, -0.1) - vec3f(-0.2, 0.1, 0.9))); // Triangle normal
                }
        
                // Calculate lighting and shading
                var lighting = calculate_lighting(hit_position, normal, closestHit.color);
                
                // For the sphere, add specular highlight
                if (sphereHit.hit) {
                    let specular = calculate_specular(hit_position, normal, ray.direction, 42.0);
                    lighting += specular;
                }
        
                return vec4f(lighting, 1.0); // Return final color with lighting
            }

            // Return background color if no hit
            return vec4f(closestHit.color, 1.0);
        }
    </script>
</head>
<body>
    <canvas id="webgpu-canvas" width="512" height="512">
        Please use a browser that supports HTML5 canvas.
    </canvas>
</body>
</html>
